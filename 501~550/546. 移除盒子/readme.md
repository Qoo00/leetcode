# 546. 移除盒子

```c++
给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k*k 个积分。
当你将所有盒子都去掉之后，求你能获得的最大积分和。

示例 1：
输入:

[1, 3, 2, 2, 2, 3, 4, 3, 1]
输出:

23
解释:

[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
 

提示：盒子的总数 n 不会超过 100。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-boxes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

写在前面：本解题参考了[Grandyang](https://www.cnblogs.com/grandyang/p/6850657.html)大神在cnblogs上的解题。

个人人为这是最难的一类动态规划了，比之前遇到的[戳气球](https://leetcode-cn.com/problems/burst-balloons/)，[祖玛游戏](https://leetcode-cn.com/problems/zuma-game/)还难。和后面的一题[奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/solution/)比较相似，主要是状态转移方程难以确定，子问题之间相互影响，计算先后顺序难以确定。

但只要解决了上述两个问题，总结好规律，就能写出代码。

首先，对于这种一维的数据，一般来讲都是通过dp[i][j]数组来表示子问题，i表示子问题的左边界，j表示子问题的右边界。本题目最大的问题就是边界之外的数据也会对边界值有影响。

为了理清子问题之间的关系，在移除盒子时，我们总是将dp[i][j]区间中的**最左边的盒子**先移除，根据移除的不同位置，就可以把问题归纳为一个更小的子问题。这时肯定会有人问，先移除最左边的盒子怎么保证这是最优解呢？其实仔细想一下就能理解，不管怎么样，**最左边的盒子一定是要移除的，只不过移除的时机不同，只要我们遍历所有的时机，从中去一个最大值，那么就肯定能保证取得的解是最优的**。

通过这一策略，有两个问题已经明确下来了：

第一个是`i，j`区间外的数字对区间结果的影响，由于我们每次试图移除最左边的数字，所以影响只局限在元素`boxes[i]`上面，加入区间`[i,j]`左边有**连续的**k个元素和`boxes[i]`相同，那么此时移除元素`boxes[i]`的收益就是 `(1+k)*(1+k) + dp[i+1][j]`（先不考虑i右边也有和boxes[i]相同的元素,因为以后肯定会计算到）。

第二个是母问题和子问题的关系，只要每次都尝试移除区间中的第一个元素，那么最后问题的规模一定也会越来越小，最终求出结果。

明确了两个问题以后，我们可以看到，除了边界`[i,j]`之外，还有一个参数和结果息息相关，那就是`boxes[i]`左边相同数字的个数k。所以dp数组应该是一个三维数组`dp[i][j][k]`。当`boxes[i]`左边有`k`个数字跟其相等时，区间`[i, j]`中能获得的最大积分，最终问题的解就是`dp[0][n-1][0]`了。

到此时，只有最后一个问题没有解决，就是我们如何遍历区间`[i,j]`之内最左边盒子移除时的不同情况。我们用一个例子来解释。

有区间`[3, 2, 2, 2, 3, 4, 3]`，最左边的数字为`3`，移除最左边的`3`无非有3种情况，分别为：

1. 直接第一步就移除，只能得1分，那么问题就成了求解 `1 + [2, 2, 2, 3, 4, 3]`

2. 先移除中间的`[2, 2, 2]`，然后移除最左边的3，子问题就成了： `[2, 2, 2] + 3~[3, 4, 3]`,已经移除的3我们记为`3~`表示**已经移除了，但是不立即计算分数**，而是成了遗留子区间`[3, 4, 3]`的前缀，那么什么时候计算分数呢，当然是子区间`[3, 4, 3]`移除一个个3时候通过公式`(1+k)*(1+k) + dp[i+1][j]`计算值的时候。当然`3~[3, 4, 3]`中区间的第一个3也可以以后移除，先移除元素`4`，然后再计算`3~3~[3]`的值，显然这个方法比较明智。

3. 和第2个`3`不结合，而是和最后一个`3`结合，也就是先移除`[2, 2, 2, 3, 4]`,然后剩余数组变为`3~[3]`，计算最大值。

可以从例子中看到，在区间`[i,j]`上，完整的状态转移方程为`dp[i][j][k]  = max(ans, dp[i+1][t-1][0] + dp[t][j][k+1] );`,其中`t`是在`[i+1,j]`区间中满足`boxes[i] == boxes[t]`的点，当然也别忘了立即移除`i`的情况`dp[i][j][k]  = (1 + k) * (1 + k) + dp[i+1][j][0]`

写了这么多原理，代码反而是最容易写出来的。

递归版，好处是不用处理子问题计算的先后顺序，交给程序执行。但坏处是函数的调用需要额外的开销。

```c++
class Solution {
public:
	int removeBoxes(vector<int>& boxes) {
		int n = boxes.size();
		int dp[100][100][100] = { 0 };
		return helper(boxes, 0, n - 1, 0, dp);
	}
	int helper(vector<int>& boxes, int i, int j, int k, int dp[100][100][100]) {
		if (j < i) return 0;
		if (dp[i][j][k] > 0) return dp[i][j][k];
		int ans = (1 + k) * (1 + k) + helper(boxes, i + 1, j, 0, dp);
		for (int t = i + 1; t <= j; t++) {
			if (boxes[i] == boxes[t]) {
				ans = max(ans, helper(boxes, i + 1, t - 1, 0, dp) + helper(boxes, t, j, k + 1, dp));
			}
		}
		return dp[i][j][k] = ans;
	}
};
```

---

>下面这种写法是上面解法的迭代方式，但是却有一些不同，这里我们需要对dp数组的部分值做一些初始化，将每个数字的所有k值的情况的积分都先算出来，然后在整体更新三维dp数组的时候也很有意思，并不是按照原有的顺序更新，而是块更新，先更新dp[1][0][k], dp[2][1][k], dp[3][2][k]....，再更新dp[2][0][k], dp[3][1][k], dp[4][2][k]...., 再更新dp[3][0][k], dp[4][1][k], dp[5][2][k] --- grandyang


也就是先把所有长度较小的区间计算完，然后计算长度较大的区间。和之前的戳气球思想比较相似。

```c++
class Solution {
public:
    int removeBoxes(vector<int>& boxes) {
        int n = boxes.size();
        int dp[n][n][n] = {0};
        for (int i = 0; i < n; ++i) {
            for (int k = 0; k <= i; ++k) {
                dp[i][i][k] = (1 + k) * (1 + k);
            }   
        }
        for (int t = 1; t < n; ++t) {//区间长度
            for (int j = t; j < n; ++j) {//区间右边界
                int i = j - t; // 左边界
                for (int k = 0; k <= i; ++k) { //相同前缀长度
                    int res = (1 + k) * (1 + k) + dp[i + 1][j][0]; //立即移除的收益
                    for (int m = i + 1; m <= j; ++m) { //遍历所有延迟移除的情况
                        if (boxes[m] == boxes[i]) {
                            res = max(res, dp[i + 1][m - 1][0] + dp[m][j][k + 1]);
                        }
                    }
                    dp[i][j][k] = res;
                }
            }
        }
        return n == 0 ? 0 : dp[0][n - 1][0];
    }
};
```



