# 31-下一个排列

执行用时 :8 ms, 在所有 C++ 提交中击败了97.74%的用户

内存消耗 :8.4 MB, 在所有 C++ 提交中击败了99.44%的用户

## 题目描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

来源：力扣（LeetCode）
链接：<https://leetcode-cn.com/problems/next-permutation>

## 主要思想

从后向前扫描到第一个顺序数对，该数对后面的数字此时全为降序排列，从降序排列中找出刚好大于该数的新数字，并交换，再将交换以后的后续数字顺序排列，此时得到的就是下一个排列。

如果全部为降序排列，此时得到的数字最大，将vector翻转，求得最小值。

## 复杂度

时间复杂度= O（n）（找顺序对） + o(logn) （找最小值） +  O（n）（翻转） =  O（n）

空间复杂度=O(1)
