# 面试题62. 圆圈中最后剩下的数字

```c++
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
 

限制：

1 <= n <= 10^5
1 <= m <= 10^6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

## 解析

约瑟夫环问题，主要有置为0，链表模拟等方法。

最快最省空间的还是递推的方法。

我们先假设第3个人出局，按照从0开始的写法，每次报数0，1，2， 也就是报2的那个人出局。

假设刚开始有5个人，编号分别为

```c
0, 1, (2), 3, 4  //第三个出局,我们不要归0，从2接着写，下一行为
3, 4, (0), 1
1, 3, (4)
1, 3, (1)
3
```

在有1个人的时候，胜利者的下标位置是0  
在有2个人的时候，胜利者的下标位置为1  
在有3个人的时候，胜利者的下标位置为1  
在有4个人的时候，胜利者的下标位置为0  

假设只有一个人时胜利者的下标为f(1) = 0
可以得出2人时胜利者的下标为f(2) = (3 + f(1))%2,总结为f(n) = (3 + f(n-1))%n

其中3 + f(n-1)，代表的是来到新的一行后（前面2个被截断，di3个出局），将f(n-1)的偏移映射到上一行，%n的总用是循环报数

当一直向上查找，偏移为n，就说明是编号为n的是最终胜利者。

```c++

class Solution {
public:
    int lastRemaining(int n,int m)
    {
        int p=0;
        for(int i=2;i<=n;i++)
        {
            p=(p+m)%i;
        }
        return p;
    }
};

```

---



