# 611. 有效三角形的个数

```c++
给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:

输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
注意:

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-triangle-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

假设三角形的三边分别为`i,j,k`，长度依次递增。

先固定最大的一条边`k`，然后使用两个指针不断靠拢，直到相遇。

相遇过程中，只要满足条件，则不必判断了，他们之间的数也一定满足条件。

---

一开始是试着固定最小的那条边`i`，后两个用指针不断靠拢，可能会漏掉解，因为可能`i,j,k`不符合三角形，但是`i,j,k-1`可能符合，

但如果是固定最后一个数，如果`i、j`可以组成三角形，`i、j`之内的数肯定可以，之外的数肯定不行，这是这一次的解个数就是`j-i`。

为什么呢？

主要是因为如果固定最小的那条边`i`，那么j向右移动和k向左移动起的效果是相同的（要求 k- j < i），所以解不是单调的，盲目缩小会漏掉解。

而固定最大的一条边`k`，`i、j`相向移动起的作用是相反的，（i + j > k）。

```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        int len = nums.size();
        for(int i=len-1;i>=0;i--){
            // i 最大边， l 最小边， r 中间边
            int l = 0,r = i -1;
            while(l<r){
                if(nums[l] + nums[r] > nums[i]){
                    ans += r-l;
                    r--;
                }else{
                    
                    l++;
                }

            }
        }
        
        return ans;
    }
};
```

---



