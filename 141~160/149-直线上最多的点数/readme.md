# 149. 直线上最多的点数

```c++
给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。

示例 1:

输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
示例 2:

输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/max-points-on-a-line
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

```c++
class Solution {
public:
	int maxPoints(vector<vector<int>>& points) {
		int len = points.size();
		if (len <= 2)
			return len;

		int ans = 2;
		for (int i = 0; i < len - 1; i++) {
			for (int j = i + 1; j < len; j++) {
				int temp = 0;
				long x1 = points[i][0], y1 = points[i][1];
				long x2 = points[j][0], y2 = points[j][1];

				if (x1 == x2 && y1 == y2) {  //会遇到两点相同的问题，故意错开一位
					x2++;  //遇到两点重合的 随便拉一条直线，不能直接跳过，防止还有更多重复的点漏掉
					y2++;
				}

				for (int k = 0; k < len; k++) {   //遍历所有点，在由上述两点所定义的直线上的点
					long x = points[k][0],y = points[k][1];

					if (((y - y1) * (x2 - x1) == (x - x1) * (y2 - y1))) {  //两点式
						temp++;
					}
				}

				ans = max(ans, temp);
			}
		}
		return ans;
	}
};
```

---

偷个懒，懒得算斜率的，写一个O(n^3)的暴力算法，用例比较少还能通过。

（需要注意的是，当两个点重叠时，不能简单地跳过，因为有多个点重叠在一起的情况，一种做法是随便将其中一个点做一个偏移，然后统计在这条线上点的个数。

---

by the way ， 对于斜率的方法，一句话解释: 固定一点, 找其他点和这个点组成直线, 统计他们的斜率!

这里有一个重点: 求斜率.用两种方法

1. 用最大约数方法(gcd), 把他化成最简形式, 3/6 == 2/4 == 1/2
2. 除数(不太精确, 速度快!)（`tmp = dy * 1000 / dx * 1000`）



